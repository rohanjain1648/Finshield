# -*- coding: utf-8 -*-
"""Untitled46.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cH7yrTF3MzDi28bynuuKKKIKEZSkfGbq
"""

# Colab cell 1
!pip install fastapi uvicorn[standard] gradio sqlalchemy scikit-learn joblib qrcode[pil] matplotlib pandas

# Colab cell 2
from google.colab import drive
drive.mount('/content/drive')

# Set persistent paths (change folder name if you want)
DRIVE_ROOT = "/content/drive/MyDrive/BehavioralBiometricsDemo"
import os
os.makedirs(DRIVE_ROOT, exist_ok=True)

MODELS_DIR = os.path.join(DRIVE_ROOT, "models")
DB_PATH    = os.path.join(DRIVE_ROOT, "behavior.db")
os.makedirs(MODELS_DIR, exist_ok=True)

# Tuning knobs (edit if needed)
USER_ENROLL_MIN_POSITIVES = 3   # how many enrolments required before scoring
KNN_NEIGHBORS = 5
SVM_KERNEL = 'rbf'
SCORE_THRESHOLD = 0.60

print("Drive mounted. Using:")
print("DRIVE_ROOT:", DRIVE_ROOT)
print("MODELS_DIR :", MODELS_DIR)
print("DB_PATH    :", DB_PATH)

# Colab cell 3
import os, joblib, threading, io, time
from datetime import datetime
from fastapi import FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from sqlalchemy import create_engine, Column, Integer, Float, String, DateTime
from sqlalchemy.orm import sessionmaker, declarative_base
import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC

# Config (from previous cell)
MODELS_DIR = MODELS_DIR
DB_PATH = DB_PATH
USER_ENROLL_MIN_POSITIVES = USER_ENROLL_MIN_POSITIVES
KNN_NEIGHBORS = KNN_NEIGHBORS
SVM_KERNEL = SVM_KERNEL
SCORE_THRESHOLD = SCORE_THRESHOLD

os.makedirs(MODELS_DIR, exist_ok=True)

# ---------- DB setup ----------
engine = create_engine(f"sqlite:///{DB_PATH}", connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)
Base = declarative_base()

class Sample(Base):
    __tablename__ = "samples"
    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(String, index=True, nullable=False)
    dwell_mean = Column(Float, default=0.0)
    dwell_std  = Column(Float, default=0.0)
    flight_mean= Column(Float, default=0.0)
    flight_std = Column(Float, default=0.0)
    key_count  = Column(Float, default=0.0)
    session_time=Column(Float, default=0.0)
    pressure_mean=Column(Float, default=0.0)
    swipe_vel  = Column(Float, default=0.0)
    gyro_x     = Column(Float, default=0.0)
    gyro_y     = Column(Float, default=0.0)
    gyro_z     = Column(Float, default=0.0)
    label      = Column(Integer, default=1)  # 1 genuine, 0 impostor
    created_at = Column(DateTime, default=datetime.utcnow)

class ScoreLog(Base):
    __tablename__ = "scores"
    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(String, index=True)
    prob_avg = Column(Float)
    prob_knn = Column(Float)
    prob_svm = Column(Float)
    verdict = Column(String)
    created_at = Column(DateTime, default=datetime.utcnow)

Base.metadata.create_all(engine)

# ---------- ML helpers ----------
FEATURES = [
    "dwell_mean","dwell_std","flight_mean","flight_std",
    "key_count","session_time","pressure_mean","swipe_vel","gyro_x","gyro_y","gyro_z"
]

def model_paths(user_id: str):
    safe = user_id.replace("/", "_")
    return {
        "scaler": os.path.join(MODELS_DIR, f"{safe}_scaler.pkl"),
        "knn":    os.path.join(MODELS_DIR, f"{safe}_knn.pkl"),
        "svm":    os.path.join(MODELS_DIR, f"{safe}_svm.pkl")
    }

def df_from_db(session, user_id: str):
    pos = session.query(Sample).filter(Sample.user_id==user_id, Sample.label==1).all()
    neg_others = session.query(Sample).filter(Sample.user_id!=user_id, Sample.label==1).all()
    neg_user = session.query(Sample).filter(Sample.user_id==user_id, Sample.label==0).all()
    def to_df(rows):
        return pd.DataFrame([{
            c: getattr(r, c) for c in ["dwell_mean","dwell_std","flight_mean","flight_std","key_count","session_time","pressure_mean","swipe_vel","gyro_x","gyro_y","gyro_z"]
        } for r in rows])
    X_pos = to_df(pos)
    X_neg = pd.concat([to_df(neg_others), to_df(neg_user)], ignore_index=True) if (neg_others or neg_user) else pd.DataFrame(columns=FEATURES)
    return X_pos, X_neg

def enough_data_to_train(session, user_id: str):
    pos_count = session.query(Sample).filter(Sample.user_id==user_id, Sample.label==1).count()
    neg_exists = session.query(Sample).filter(Sample.user_id!=user_id, Sample.label==1).first() is not None or \
                 session.query(Sample).filter(Sample.user_id==user_id, Sample.label==0).first() is not None
    return pos_count >= USER_ENROLL_MIN_POSITIVES and neg_exists

def train_per_user_models(user_id: str):
    sess = SessionLocal()
    try:
        X_pos, X_neg = df_from_db(sess, user_id)
        if X_pos.empty:
            return False, "No positive/enroll samples yet"
        if X_neg.empty:
            return False, "No negatives available (need other users or impostor labels)"
        X_pos["label"] = 1
        X_neg["label"] = 0
        df = pd.concat([X_pos, X_neg], ignore_index=True)
        X = df[FEATURES].fillna(0.0).values
        y = df["label"].values.astype(int)
        scaler = StandardScaler().fit(X)
        Xs = scaler.transform(X)
        knn = KNeighborsClassifier(n_neighbors=KNN_NEIGHBORS)
        knn.fit(Xs, y)
        svm = SVC(kernel=SVM_KERNEL, probability=True)
        svm.fit(Xs, y)
        paths = model_paths(user_id)
        joblib.dump(scaler, paths["scaler"])
        joblib.dump(knn, paths["knn"])
        joblib.dump(svm, paths["svm"])
        return True, f"Trained: {len(X_pos)} pos / {len(X_neg)} neg"
    finally:
        sess.close()

def load_models(user_id: str):
    p = model_paths(user_id)
    if not (os.path.exists(p["scaler"]) and os.path.exists(p["knn"]) and os.path.exists(p["svm"])):
        return None, None, None
    return joblib.load(p["scaler"]), joblib.load(p["knn"]), joblib.load(p["svm"])

def score_features(user_id: str, feat: dict):
    models = load_models(user_id)
    if models[0] is None:
        return None
    scaler, knn, svm = models
    x = np.array([[float(feat.get(k,0.0)) for k in FEATURES]])
    xs = scaler.transform(x)
    p_knn = float(knn.predict_proba(xs)[0][1]) if hasattr(knn, "predict_proba") else float(knn.predict(xs)[0])
    p_svm = float(svm.predict_proba(xs)[0][1])
    avg = (p_knn + p_svm) / 2.0
    return {"prob_knn": p_knn, "prob_svm": p_svm, "avg": avg, "verdict": "genuine" if avg >= SCORE_THRESHOLD else "impostor"}

# ---------- FastAPI app ----------
app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # adjust in prod
    allow_methods=["*"],
    allow_headers=["*"],
)

class FeaturesPayload(BaseModel):
    user_id: str
    features: dict

class LabelPayload(BaseModel):
    user_id: str
    label: int
    features: dict

@app.post("/enroll")
def enroll(payload: FeaturesPayload):
    sess = SessionLocal()
    try:
        feat = payload.features
        s = Sample(
            user_id=payload.user_id,
            dwell_mean=float(feat.get("dwell_mean",0.0)),
            dwell_std=float(feat.get("dwell_std",0.0)),
            flight_mean=float(feat.get("flight_mean",0.0)),
            flight_std=float(feat.get("flight_std",0.0)),
            key_count=float(feat.get("key_count",0.0)),
            session_time=float(feat.get("session_time",0.0)),
            pressure_mean=float(feat.get("pressure_mean",0.0)),
            swipe_vel=float(feat.get("swipe_vel",0.0)),
            gyro_x=float(feat.get("gyro_x",0.0)),
            gyro_y=float(feat.get("gyro_y",0.0)),
            gyro_z=float(feat.get("gyro_z",0.0)),
            label=1
        )
        sess.add(s); sess.commit()
        train_info = None
        if enough_data_to_train(sess, payload.user_id):
            ok,msg = train_per_user_models(payload.user_id)
            train_info = msg if ok else f"train skipped: {msg}"
        pos_count = sess.query(Sample).filter(Sample.user_id==payload.user_id, Sample.label==1).count()
        return {"status":"enrolled","user_id":payload.user_id,"positives":pos_count,"train_info":train_info}
    finally:
        sess.close()

@app.post("/score")
def score(payload: FeaturesPayload):
    sess = SessionLocal()
    try:
        pos_count = sess.query(Sample).filter(Sample.user_id==payload.user_id, Sample.label==1).count()
        if pos_count < USER_ENROLL_MIN_POSITIVES:
            return {"status":"need_enroll","positives":pos_count,"message":f"Need at least {USER_ENROLL_MIN_POSITIVES} enrollments"}
        # ensure model available (train if possible)
        scaler, knn, svm = load_models(payload.user_id)
        if scaler is None:
            if enough_data_to_train(sess, payload.user_id):
                ok,msg = train_per_user_models(payload.user_id)
                if not ok:
                    return {"status":"not_ready","message":msg}
            else:
                return {"status":"not_ready","message":"Not enough negatives (enroll other users or label impostors)"}
        res = score_features(payload.user_id, payload.features)
        if res is None:
            return {"status":"error","message":"models not ready"}
        # log to scores
        log = ScoreLog(user_id=payload.user_id, prob_avg=res["avg"], prob_knn=res["prob_knn"], prob_svm=res["prob_svm"], verdict=res["verdict"])
        sess.add(log); sess.commit()
        return {"status":"ok", **res}
    finally:
        sess.close()

@app.post("/label")
def label(payload: LabelPayload):
    sess = SessionLocal()
    try:
        feat = payload.features
        s = Sample(
            user_id=payload.user_id,
            dwell_mean=float(feat.get("dwell_mean",0.0)),
            dwell_std=float(feat.get("dwell_std",0.0)),
            flight_mean=float(feat.get("flight_mean",0.0)),
            flight_std=float(feat.get("flight_std",0.0)),
            key_count=float(feat.get("key_count",0.0)),
            session_time=float(feat.get("session_time",0.0)),
            pressure_mean=float(feat.get("pressure_mean",0.0)),
            swipe_vel=float(feat.get("swipe_vel",0.0)),
            gyro_x=float(feat.get("gyro_x",0.0)),
            gyro_y=float(feat.get("gyro_y",0.0)),
            gyro_z=float(feat.get("gyro_z",0.0)),
            label=int(payload.label)
        )
        sess.add(s); sess.commit()
        train_msg = None
        if enough_data_to_train(sess, payload.user_id):
            ok,msg = train_per_user_models(payload.user_id)
            train_msg = msg if ok else msg
        counts = {
            "positives": sess.query(Sample).filter(Sample.user_id==payload.user_id, Sample.label==1).count(),
            "impostors": sess.query(Sample).filter(Sample.user_id==payload.user_id, Sample.label==0).count()
        }
        return {"status":"labeled","user_id":payload.user_id,"counts":counts,"train_info":train_msg}
    finally:
        sess.close()

@app.get("/status")
def status():
    sess = SessionLocal()
    try:
        df = pd.read_sql_table("samples", con=engine)
        if df.empty:
            return {"users":{}}
        summary = df.groupby("user_id")["label"].agg(
            positives=lambda s: int((s==1).sum()),
            impostors=lambda s: int((s==0).sum())
        ).reset_index()
        users = {r["user_id"]: {"positives": int(r["positives"]), "impostors": int(r["impostors"])} for _,r in summary.iterrows()}
        return {"users":users}
    finally:
        sess.close()

@app.get("/users")
def users():
    sess = SessionLocal()
    try:
        rows = sess.query(Sample.user_id).distinct().all()
        ulist = sorted([r[0] for r in rows])
        return {"users":ulist}
    finally:
        sess.close()

@app.get("/metrics")
def metrics(user_id: str):
    sess = SessionLocal()
    try:
        q = sess.query(ScoreLog).filter(ScoreLog.user_id==user_id).order_by(ScoreLog.created_at.asc()).all()
        ts = [r.created_at.isoformat() for r in q]
        avg = [float(r.prob_avg) for r in q]
        knn = [float(r.prob_knn) for r in q]
        svm = [float(r.prob_svm) for r in q]
        return {"timestamps":ts,"prob_avg":avg,"prob_knn":knn,"prob_svm":svm}
    finally:
        sess.close()

# ---------- Start uvicorn in background thread ----------
def run_uvicorn():
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000, log_level="info")

threading.Thread(target=run_uvicorn, daemon=True).start()
print("FastAPI started on port 8000")

# Colab cell 4
import gradio as gr
import requests, json, io, qrcode, matplotlib.pyplot as plt
from PIL import Image
import base64
import time

FASTAPI_BASE = "http://127.0.0.1:8000"  # FastAPI running in same Colab

# HTML snippet: captures keystroke timings & touch features and calls FastAPI endpoints directly.
# The HTML runs in the browser (opened by Gradio). It uses fetch() to POST to the FastAPI endpoints.
HTML_APP = f"""
<div style="font-family:system-ui, Arial; max-width:900px;">
  <h3>Pillar B — Behavioral Biometrics Demo (Gradio + FastAPI)</h3>
  <div>User ID: <input id="userId" value="user1" /></div>
  <p>Type naturally in the box below. Use <b>Enroll</b> to create a genuine sample (repeat {USER_ENROLL_MIN_POSITIVES} times). Then use <b>Score</b>.</p>
  <textarea id="box" rows="8" style="width:100%; display:block; border: 1px solid #ccc; padding: 8px;"></textarea><br/>
  <button onclick="enroll()">Enroll</button>
  <button onclick="score()">Score</button>
  <button onclick="label(1)">Label = Genuine</button>
  <button onclick="label(0)">Label = Impostor</button>
  <label><input type="checkbox" id="auto" /> Continuous (10s)</label>
  <div id="out" style="white-space:pre-wrap; background:#f6f8fa; padding:8px; margin-top:8px; border: 1px solid #ccc;"></div>
  <script>
    let kd = {{}}, lastUp=0;
    let dwellList=[], flightList=[];
    let pressList=[], swipeList=[], lastTouch=null;
    let gyroX=[],gyroY=[],gyroZ=[];
    let sessionStart = Date.now();

    const box = document.getElementById('box');
    box.addEventListener('keydown', e => {{ kd[e.code]=Date.now(); }});
    box.addEventListener('keyup', e => {{
      const up = Date.now();
      const down = kd[e.code] || up;
      dwellList.push(up-down);
      if (lastUp) flightList.push(down-lastUp);
      lastUp = up;
    }});

    // touch capture for mobile
    document.addEventListener('touchstart', e => {{
      if(e.touches && e.touches[0]) {{
        const t = e.touches[0];
        if(typeof t.force !== 'undefined') pressList.push(t.force || 0);
        lastTouch = {{x:t.clientX,y:t.clientY,t:performance.now()}};
      }}
    }}, {{passive:true}});
    document.addEventListener('touchmove', e => {{
      if(e.touches && e.touches[0] && lastTouch) {{
        const t = e.touches[0];
        const dt = (performance.now()-lastTouch.t)/1000.0;
        const dx = t.clientX - lastTouch.x;
        const dy = t.clientY - lastTouch.y;
        const vel = dt>0 ? Math.sqrt(dx*dx+dy*dy)/dt : 0;
        swipeList.push(vel);
        lastTouch = {{x:t.clientX,y:t.clientY,t:performance.now()}};
      }}
    }}, {{passive:true}});

    // device motion (gyro) - mobile
    if(window.DeviceMotionEvent){{
      window.addEventListener('devicemotion', e => {{
        const r = e.rotationRate || {{}};
        gyroX.push(r.alpha||0); gyroY.push(r.beta||0); gyroZ.push(r.gamma||0);
      }}, true);
    }}

    function mean(a){{ if(!a.length) return 0; return a.reduce((x,y)=>x+y,0)/a.length; }}
    function std(a){{ if(!a.length) return 0; const m=mean(a); return Math.sqrt(a.reduce((s,x)=>s+(x-m)*(x-m),0)/a.length); }}

    function features(){{
      return {{
        dwell_mean: mean(dwellList),
        dwell_std: std(dwellList),
        flight_mean: mean(flightList),
        flight_std: std(flightList),
        key_count: dwellList.length,
        session_time: (Date.now()-sessionStart)/1000.0,
        pressure_mean: mean(pressList),
        swipe_vel: mean(swipeList),
        gyro_x: mean(gyroX), gyro_y: mean(gyroY), gyro_z: mean(gyroZ)
      }};
    }}

    async function api(path, payload){{
      const url = "{FASTAPI_BASE}" + path;
      const r = await fetch(url, {{
        method:'POST',
        headers: {{ 'Content-Type': 'application/json' }},
        body: JSON.stringify(payload)
      }});
      return await r.json();
    }}

    async function enroll(){{
      const uid = document.getElementById('userId').value;
      const f = features();
      document.getElementById('out').textContent = 'Enroll → ' + JSON.stringify(f,null,2);
      const res = await api('/enroll', {{ user_id: uid, features: f }});
      document.getElementById('out').textContent += '\\n' + JSON.stringify(res,null,2);
      // reset session
      dwellList=[]; flightList=[]; pressList=[]; swipeList=[]; gyroX=[]; gyroY=[]; gyroZ=[]; lastUp=0; sessionStart=Date.now(); box.value='';
    }}

    async function score(){{
      const uid = document.getElementById('userId').value;
      const f = features();
      document.getElementById('out').textContent = 'Score → ' + JSON.stringify(f,null,2);
      const res = await api('/score', {{ user_id: uid, features: f }});
      document.getElementById('out').textContent += '\\n' + JSON.stringify(res,null,2);
    }}

    async function label(l){{
      const uid = document.getElementById('userId').value;
      const f = features();
      const res = await api('/label', {{ user_id: uid, label: l, features: f }});
      document.getElementById('out').textContent = 'Label(' + l + ') → ' + JSON.stringify(res,null,2);
      dwellList=[]; flightList=[]; pressList=[]; swipeList=[]; gyroX=[]; gyroY=[]; gyroZ=[]; lastUp=0; sessionStart=Date.now(); box.value='';
    }}

    // continuous
    let timer=null;
    document.getElementById('auto').addEventListener('change', function(){{
      if(this.checked){{ timer = setInterval(score, 10000); }} else {{ clearInterval(timer); }}
    }});
  </script>
</div>
"""

# Gradio: function to fetch dashboard data (from /metrics) and produce a matplotlib figure
def plot_metrics(user_id: str):
    if not user_id:
        return None
    try:
        r = requests.get(f"{FASTAPI_BASE}/metrics", params={"user_id": user_id}, timeout=5)
        j = r.json()
    except Exception as e:
        return None
    ts = j.get("timestamps", [])
    avg = j.get("prob_avg", [])
    knn = j.get("prob_knn", [])
    svm = j.get("prob_svm", [])
    if not ts:
        # empty: return text image
        fig, ax = plt.subplots(figsize=(8,3))
        ax.text(0.5,0.5,"No score logs yet for user: "+user_id, ha='center', va='center', fontsize=14)
        ax.axis('off')
    else:
        fig, ax = plt.subplots(figsize=(9,4))
        ax.plot(ts, avg, label='avg', marker='o')
        ax.plot(ts, knn, label='knn', marker='x')
        ax.plot(ts, svm, label='svm', marker='s')
        ax.set_ylim(-0.05,1.05)
        ax.set_xticklabels(ts, rotation=45, ha='right')
        ax.set_title(f"Risk trend for {user_id}")
        ax.legend()
        ax.grid(alpha=0.2)
        fig.tight_layout()
    buf = io.BytesIO()
    fig.savefig(buf, format='png')
    buf.seek(0)
    plt.close(fig)
    return buf

def get_users():
    try:
        r = requests.get(f"{FASTAPI_BASE}/users", timeout=3)
        j = r.json()
        return j.get("users", [])
    except:
        return []

# Build Gradio interface:
with gr.Blocks() as demo:
    gr.Markdown("## Pillar B — Real-time Behavioral Biometrics\nFrontend (embedded HTML) talks to FastAPI endpoints. Use the QR/share link to open on your phone.")
    with gr.Row():
        with gr.Column(scale=2):
            gr.HTML(HTML_APP)
        with gr.Column(scale=1):
            user_sel = gr.Dropdown(choices=get_users(), label="Select user for Dashboard", interactive=True)
            btn_refresh = gr.Button("Refresh users")
            btn_plot = gr.Button("Show Risk Trend")
            out_plot = gr.Image(type="pil")
            info = gr.Textbox(label="Latest status / messages", lines=6)

    def refresh_users():
        users = get_users()
        return gr.Dropdown.update(choices=users), f"Found {len(users)} users"
    btn_refresh.click(fn=refresh_users, inputs=None, outputs=[user_sel, info])

    def show_plot(uid):
        buf = plot_metrics(uid)
        if buf is None:
            return None
        img = Image.open(buf)
        return img
    btn_plot.click(fn=show_plot, inputs=user_sel, outputs=out_plot)

    # Show a small help panel
    gr.Markdown("""
    **How to demo**
    1. Enter a user id on the left (e.g., user1). Click **Enroll** at least %d times.
    2. Enroll another user (user2) a couple times to provide negatives.
    3. On left, click **Score** for real-time decision. Use **Label** to correct and update the model.
    4. Use **Show Risk Trend** on right to view the time series of scores.
    5. Use the Gradio _share_ link (appears after deploy) or the QR code to open on phone.
    """ % USER_ENROLL_MIN_POSITIVES)

# Launch Gradio and capture share link
app_url = demo.launch(share=True, server_name="0.0.0.0", server_port=7862)  # returns (local_url, share_url) in older versions; we print below
print("Gradio launched.")
# app_url sometimes is tuple; handle both cases:
try:
    if isinstance(app_url, tuple):
        local_url, share_url = app_url
    else:
        # new gradio returns a string share url
        share_url = app_url
except:
    share_url = None

print("Share URL (open on phone):", share_url)

# Generate and display QR code (save to Drive if desired)
if share_url:
    qr = qrcode.make(share_url)
    qr_path = os.path.join(MODELS_DIR, "gradio_share_qr.png")
    qr.save(qr_path)
    print("Saved QR to:", qr_path)
    display(qr)
else:
    print("No share URL available (Gradio returned None). If using Colab, Gradio should return a share link.")

